# Огляд застосунку "Облік закупівель"

## 1. Призначення та ключові можливості
- **PWA для польової команди**: додаток збирає закупки, відвантаження та доставки з мобільних пристроїв. Інтерфейс розбитий на головний екран з картками швидкого старту, історію операцій та прості звіти з графіком на Chart.js.【F:index.html†L38-L127】【F:index.html†L193-L208】
- **Робота офлайн**: service worker кешує shell (HTML, CSS, JS, шрифти) і підтримує стратегії `networkFirst`/`cacheFirst`, що дозволяє відкривати додаток без мережі.【F:service-worker.js†L1-L53】
- **Режими роботи**: перемикач "робочий / тестовий" міняє цільовий webhook n8n для надсилання даних, зберігаючи вибір у localStorage.【F:app.js†L48-L133】【F:app.js†L540-L563】
- **AI-звіт**: при завершенні дня клієнт може зібрати історію з sessionStorage та надіслати її в Gemini API (ключ за замовчуванням порожній).【F:app.js†L418-L465】【F:app.js†L1007-L1035】

## 2. Архітектура клієнта
- **Vanilla JS + DOM** без фреймворку. Логіка організована у класи (`SecureConfig`, `AppState`, `SecureApiClient`, `SecureStorageManager`, `ToastManager`, `ThemeManager`) та набір процедур для обробки форм, історії, UI перемикань.【F:app.js†L5-L341】【F:app.js†L468-L763】
- **Стан**: `AppState` тримає поточний екран, вкладку та тип операції. Однак ідентифікатори вкладок у коді (`purchasesTab`, `historyTab`) не збігаються з фактичними DOM-елементами (`homeTab`, `purchasesListTab`, `unloadingListTab`, `reportsTab`), що робить зовнішній `app.js` нефункціональним у поточному HTML.【F:app.js†L181-L213】【F:index.html†L38-L127】
- **Сховище**: "оптимізована" версія з `app.js` пише історію у `sessionStorage`, очищаючи дані після перезавантаження вкладки.【F:app.js†L234-L276】 У вбудованому в `index.html` сценарії попередньої версії історія зберігається у `localStorage` та має додаткові можливості (редагування, пакетна відправка, сортування).【F:index.html†L229-L331】【F:index.html†L492-L620】
- **Подвійна логіка**: внизу `index.html` залишився великий inline-скрипт ("ІСПРАВЛЕННАЯ ВЕРСИЯ"), який повністю дублює функціональність, але з іншою структурою стану (`tab: 'home'`, `localStorage`, інші ідентифікатори).【F:index.html†L209-L620】 Через це одночасно існують дві несумісні реалізації, і браузер виконує саме inline-варіант (підключений останнім), ігноруючи винесений `app.js`.

## 3. Потоки даних і інтеграції
- **Надсилання заявки**: при сабміті форми збираються валідовані поля, файл конвертується у base64 і формується payload з пласкими та секційними даними. Запит йде на webhook n8n через Fetch з таймаутом і запасним URL для тестового режиму.【F:app.js†L486-L959】
- **Проксі `/api/delivery`**: Node handler читає raw body (JSON або multipart) та пересилає його на публічний n8n webhook, зберігаючи потрібні заголовки і підтримуючи CORS через список дозволених origins.【F:api/delivery.ts†L1-L102】
- **AI-інтеграція**: історія конвертується в текстовий список для Gemini. Без ключа функція повертає помилку "AI API not configured", що показується в модальному вікні.【F:app.js†L418-L465】【F:app.js†L1019-L1024】

## 4. Інтерфейс і UX
- **UI** стилізований через скруглені картки, `glassmorphism`, темну тему та анімації; темний режим перемикається в атрибуті `data-theme` і зберігається в localStorage.【F:styles.css†L1-L120】【F:styles.css†L320-L340】
- **Повідомлення**: `ToastManager` реалізує чергу повідомлень з анімацією fade-out для уникнення "флікера" при швидких подіях.【F:app.js†L278-L315】
- **Фото**: підтримуються зображення до 5 МБ, читання через FileReader, превʼю і можливість видалення до відправлення.【F:app.js†L40-L45】【F:app.js†L748-L771】

## 5. Питання та ризики
1. **Конфліктні реалізації**. Inline-скрипт і `app.js` суперечать один одному (різні ідентифікатори, сховища, функції, назви вкладок). Це ускладнює підтримку і може призвести до "мертвого" коду або непередбачуваної поведінки при часткових оновленнях.【F:app.js†L181-L213】【F:index.html†L209-L620】
2. **Непослідовне сховище**. Перехід на `sessionStorage` в зовнішньому скрипті стирає історію при перезавантаженні, тоді як UI (кнопка "Відправити всі", секція звітів) розрахований на довготривале зберігання в `localStorage`. Потрібно обрати єдину стратегію та синхронізувати її з сервером.【F:app.js†L234-L276】【F:index.html†L473-L573】
3. **Неповна інтеграція режимів/модалок**. Кнопка "Завершити день" у DOM викликає `showEndDayModal`, якої немає в `app.js`, зате присутня у старому inline-коді разом з модальними елементами `endDayModal`. Новий код використовує інший модальний шаблон (`aiSummaryModal`), якого в HTML нема, що блокує AI-звіт без ручних правок розмітки.【F:index.html†L62-L88】【F:app.js†L1007-L1038】
4. **Відсутність CSP / безпека**. README декларує CSP, але в HTML немає заголовків чи meta-тегу `Content-Security-Policy`. Крім того, в історії використовується `innerHTML` для блоку деталей, що все ще вразливе до XSS, якщо обʼєкти потраплять із зовнішнього джерела.【F:README.md†L1-L59】【F:app.js†L987-L993】
5. **Технічний борг у верстці**. Використовується багато інлайн-обробників `onclick`, дубльовані SVG/іконки, відсутні aria-атрибути на модалці, а компоненти не розбиті на менші модулі. Це утруднює тестування й розширення UI.【F:index.html†L47-L188】【F:index.html†L209-L620】

## 6. Рекомендації
- Видалити inline-скрипт із `index.html`, залишивши одну актуальну реалізацію в `app.js`, та оновити HTML під її селектори/модалки.
- Визначити політику зберігання історії (session vs local) і синхронізувати її з бекендом/UX.
- Додати реальний CSP через заголовки сервера або `<meta http-equiv>`, а також уникати `innerHTML` там, де можливо.
- Винести UI-компоненти (кнопки, картки, модалки) в шаблони/partials або принаймні уніфікувати інтерфейс та ідентифікатори.
- Розглянути підключення тестів (e2e / unit) хоча б для валідаторів та API-клієнта, оскільки зараз `npm test` лише виводить повідомлення.

